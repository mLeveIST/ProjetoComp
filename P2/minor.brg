%{

/* -----------------------------------------
 * Compiladores 19/20 - Entrega Final (Melhoria)
 * Author: Miguel Levezinho, No 90756
 * -----------------------------------------
 */

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;

static int strinit;

static int lbl;
static char *lb;

/* Auxiliary stacks that store label numbers for JMP/LABEL pairs
 * in cases where the label to match cannot be accessed directly
 * or by accessing child nodes.
 *
 * Stacks are used instead of single integers to acomudate cases
 * of nested blocks that use the same code segments.
 */

static int elb[20]; /* Stack for elif/else jump out labels */
static int elbl = -1; /* Top of useful elb stack */

static int flb[20]; /* Stack for for loop condition labels */
static int flbl = -1; /* Top of useful flb stack */

static int rlb[60]; /* Stack for for loop repeat labels */
static int rlbl = -1; /* Top of useful rlb stack */

static int slb[60]; /* Stack for for loop stop labels */
static int slbl = -1; /* Top of useful slb stack */

static int lcarr[20];
static int lcarrdim[20];
static int lcarrp = -1;

static char *externs[100];
static int extcnt;

static int lcvarcnt;
static int argcnt = 1;

static int imut;

static char *mklbl(int n)
{
  static char buf[20];
  sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
  return strcpy(malloc(strlen(buf) + 1), buf);
}

static char *mkfunc(char *s)
{
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}

static void printrlb()
{
  if (rlbl == -1)
    return;

  while (rlbl != -1 && rlb[rlbl--])
    fprintf(yyout, pfLABEL, mklbl(rlb[rlbl + 1]));
}

static void printslb()
{
  if (slbl == -1)
    return;

  while (slbl != -1 && slb[slbl--])
    fprintf(yyout, pfLABEL, mklbl(slb[slbl + 1]));
}

static char *mkelbl(int n) { return mklbl(elb[++elbl] = n); }
static char *mkflbl(int n) { return mklbl(flb[++flbl] = n); }
static char *mkrlbl(int n) { return mklbl(rlb[++rlbl] = n); }
static char *mkslbl(int n) { return mklbl(slb[++slbl] = n); }

static int isResInt(Node *n) { return tTYPE(n->info) == tINT ? 1 : 1000; }
static int isResStr(Node *n) { return tTYPE(n->info) == tSTR ? 1 : 1000; }
static int isResVec(Node *n) { return tTYPE(n->info) == tVEC ? 1 : 1000; }

static int isArgInt(Node *n)
{
  return (tTYPE(LEFT_CHILD(n)->info) == tINT && tTYPE(RIGHT_CHILD(n)->info) == tINT) ? 1 : 1000;
}

static int isArgStr(Node *n)
{
  return (tTYPE(LEFT_CHILD(n)->info) == tSTR && tTYPE(RIGHT_CHILD(n)->info) == tSTR) ? 1 : 1000;
}

static int isArgVec(Node *n)
{
  return (tTYPE(LEFT_CHILD(n)->info) == tVEC && tTYPE(RIGHT_CHILD(n)->info) == tVEC) ? 1 : 1000;
}

static int isLeftInt(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tINT ? 1 : 1000; }
static int isLeftStr(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tSTR ? 1 : 1000; }

static int isLftVec(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tVEC ? 1 : 1000; }
static int isRgtVec(Node *n) { return tTYPE(RIGHT_CHILD(n)->info) == tVEC ? 1 : 1000; }

static int isPub(Node *n) { return (n->info & tPUB) ? 1 : 1000; }
static int isFwd(Node *n) { return (n->info & tFWD) ? 1 : 1000; }

static int isCst(Node *n) { return (n->info & tCNST) ? 1 : 1000; }
static int isnCst(Node *n) { return (n->info & tCNST) == 0 ? 1 : 1000; }

static int isImut(Node *n) { return imut != 0 ? 1 : 1000; }
static int isnImut(Node *n) { return imut == 0 ? 1 : 1000; }

static int isGlb(Node *n) { return IDfind(n->value.s, ((void**) IDtest)) >= 0 ? 1 : 1000; }
static int isLoc(Node *n) { return IDfind(n->value.s, ((void**) IDtest)) < 0 ? 1 : 1000; }
static int isRightGlb(Node *n) { return IDfind(RIGHT_CHILD(n)->value.s, ((void**) IDtest)) >= 0 ? 1 : 1000; }
static int isRightLoc(Node *n) { return IDfind(RIGHT_CHILD(n)->value.s, ((void**) IDtest)) < 0 ? 1 : 1000; }

static void litstr(char *s)
{
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
}

static void pubdcl(int type, char *name)
{
  int i;

  if (type & tPUB)
  {
    if (type & tFUNC)
      fprintf(yyout, pfGLOBL, name, pfFUNC);
    else
      fprintf(yyout, pfGLOBL, name, pfOBJ);
  }

  for (i = 0; i < extcnt; i++)
    if (externs[i] && strcmp(externs[i], name) == 0)
      externs[i] = 0;
}

static int varqualif(int type, char* name)
{
  int i;

  if (type & tFWD)
  {
    externs[extcnt++] = strdup(name);
    return 0;
  }

  if (type & tPUB)
    fprintf(yyout, pfGLOBL, name, pfOBJ);

  for (i = 0; i < extcnt; i++)
    if (externs[i] && strcmp(externs[i], name) == 0)
      externs[i] = 0;

  return 1;
}

static void numvar(Node *id, int init)
{
  int type = id->info;
  char *name = id->value.s;

  if (!varqualif(type, name))
    return;

  if (type & tCNST)
    fprintf(yyout, pfRODATA pfALIGN pfLABEL pfINTEGER, name, init);
  else if (init == -1)
    fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, name, 4);
  else
    fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, name, init);
}

static void ptrvar(Node *id, int ptrlbl)
{
  int type = id->info;
  char *name = id->value.s;

  if (!varqualif(type, name))
    return;

  if (type & tCNST)
    fprintf(yyout, pfRODATA pfALIGN pfLABEL pfID, name, mklbl(ptrlbl));
  else if (ptrlbl == -1) 
    fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, name, pfWORD);
  else
    fprintf(yyout, pfDATA pfALIGN pfLABEL pfID, name, mklbl(ptrlbl));
}

static void initarr(int dim, int inited)
{
  int init = dim - inited;

  while (init-- > 0)
    fprintf(yyout, pfINTEGER, 0);
}

static void initlcarr()
{
  while (lcarrp >= 0 && lcarrdim[lcarrp] != 0)
  {
    fprintf(yyout, pfLOCAL pfLOCA, (lcarr[lcarrp] * 4) + 4, lcarr[lcarrp] * 4);
    --lcarrp;
  }
}

static void testfunc(int type, Node *var)
{
  if (type & tFWD)
  {
    externs[extcnt++] = strdup(LEFT_CHILD(var)->value.s);
    return;
  }

  pubdcl(type, mkfunc(LEFT_CHILD(var)->value.s));

  fprintf(yyout, pfTEXT pfALIGN pfLABEL pfENTER, mkfunc(LEFT_CHILD(var)->value.s), lcvarcnt * 4);
}

static void newid(char *id, int offset)
{
  Node *aux = nilNode(VOID);
  aux->place = offset;
  IDnew(-1, id, aux);
}

static int getoffset(char *id)
{
  Node *aux;
  IDfind(id, (void**) &aux);
  return aux->place;
}

static void indexation(char *id, int type)
{
  Node *offset;

  if (tTYPE(type) == tVEC)
    fprintf(yyout, pfIMM pfMUL, pfWORD);
  else if (tTYPE(type) == tSTR)
    fprintf(yyout, pfIMM pfMUL, 1);

  if (IDfind(id, (void**) &offset) == -1)
    fprintf(yyout, pfLOCV pfADD, (int) offset->place * 4);
  else
    fprintf(yyout, pfADDRV pfADD, id);
}

static void association(int type)
{
  if (tTYPE(type) == tVEC)
    fprintf(yyout, pfSTORE);
  else if (tTYPE(type) == tSTR)
    fprintf(yyout, pfSTCHR);
}

static void allocation(char *id, int type)
{
  Node *offset;

  if (tTYPE(type) == tVEC)
    fprintf(yyout, pfIMM, pfWORD);
  else if (tTYPE(type) == tSTR)
    fprintf(yyout, pfIMM, 1);

  fprintf(yyout, pfMUL pfALLOC pfSP);

  if (IDfind(id, (void**) &offset) == -1)
    fprintf(yyout, pfLOCA, (int) offset->place * 4);
  else
    fprintf(yyout, pfADDRA, id);
}

static void vectoradd(char *id)
{
  Node *offset;

  if (IDfind(id, (void**) &offset) == -1)
    fprintf(yyout, pfLOCV pfADD, (int) offset->place * 4);
  else
    fprintf(yyout, pfADDRV pfADD, id);
}

static void vectorsub(char *id1, char *id2)
{
  Node *offset;

  if (IDfind(id1, (void**) &offset) == -1)
    fprintf(yyout, pfLOCV, (int) offset->place * 4);
  else
    fprintf(yyout, pfADDRV, id1);

  if (IDfind(id2, (void**) &offset) == -1)
    fprintf(yyout, pfLOCV pfSUB, (int) offset->place * 4);
  else
    fprintf(yyout, pfADDRV pfSUB, id2);
}

%}

%term STMT=';' PRINT='!' ALLOC='#' INDEX='[' READ='?'
%term ADD='+' SUB='-' MULT='*' DIV='/' MOD='%' EXP='^'
%term EQ='=' LT='<' GT='>' AND='&' OR='|' NOT='~'
%term CALL='(' PARAMS=','

%include "y.tab.h"

%%

file: PROGRAM(decls, FUNCTION(fend, FARGS(NIL, main)))      1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); IDpop(); }
file: MODULE(decls)                                         1 { /**/ }

fend: END(ID, INT)                      1 { IDpush(); }

decls: gdecls                           1 { /**/ }

gdecls: NIL                             1 { /**/ }
gdecls: DECL(gdecls, decl)              1 { argcnt = 0; lcvarcnt = 0; }

decl: NIL                                                 1 { /**/ }
decl: VAR(vardecl)                                        1 { /**/ }
decl: FUNCTION(fend, FARGS(fargs, body))                  1 { IDpop(); }
decl: FUNCTION(fend, FARGS(fargs, body))              isPub { testfunc(p->info, LEFT_CHILD(p)); IDpop(); }

farg: NUMBER(ID, NIL)                   1 { newid(LEFT_CHILD(p)->value.s, ++argcnt); }
farg: STRING(ID, NIL)                   1 { newid(LEFT_CHILD(p)->value.s, ++argcnt); }
farg: ARRAY(ID, INTS(INT, NIL))         1 { newid(LEFT_CHILD(p)->value.s, ++argcnt); }

fargs: NIL                              1 { /**/ }
fargs: ARGS(fargs, farg)                1 { /**/ }

fvar: NUMBER(ID, NIL)                   1 { newid(LEFT_CHILD(p)->value.s, -(++lcvarcnt)); }
fvar: STRING(ID, NIL)                   1 { newid(LEFT_CHILD(p)->value.s, -(++lcvarcnt)); }
fvar: ARRAY(ID, INTS(INT, NIL))         1 { newid(LEFT_CHILD(p)->value.s, -(lcvarcnt += (LEFT_CHILD(RIGHT_CHILD(p))->value.i + 1)));
                                            lcarr[++lcarrp] = -lcvarcnt; lcarrdim[lcarrp] = LEFT_CHILD(RIGHT_CHILD(p))->value.i; }

fvars: NIL                              1 { imut = 1; }
fvars: ARGS(fvars, fvar)                1 { /**/ }

vardecl: NUMBER(ID, NIL)                1 { numvar(LEFT_CHILD(p), -1); }
vardecl: NUMBER(ID, INT)                1 { numvar(LEFT_CHILD(p), RIGHT_CHILD(p)->value.i); }
vardecl: STRING(ID, NIL)                1 { ptrvar(LEFT_CHILD(p), -1); }
vardecl: STRING(vid, chars)             1 { fprintf(yyout, pfCHAR, 0);
                                            ptrvar(LEFT_CHILD(p), RIGHT_CHILD(p)->place); }
vardecl: ARRAY(vid, array)              1 { ptrvar(LEFT_CHILD(p), RIGHT_CHILD(p)->place); }

vid: ID                            isnCst { imut = 0; }
vid: ID                             isCst { imut = 1; }

chars: NIL                         isImut { fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(p->place = ++lbl)); }
chars: NIL                        isnImut { fprintf(yyout, pfDATA pfALIGN pfLABEL, mklbl(p->place = ++lbl)); }
chars: CHARS(chars, char)               1 { p->place = LEFT_CHILD(p)->place; }

char: INT                               1 { fprintf(yyout, pfCHAR, (unsigned char) p->value.i); }
char: CHAR                              1 { fprintf(yyout, pfCHAR, (unsigned char) p->value.i); }
char: STR                               1 { litstr(p->value.s); }

array: INTS(INT, NIL)              isImut { fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(p->place = ++lbl));
                                            initarr(LEFT_CHILD(p)->value.i, 0); }
array: INTS(INT, NIL)             isnImut { fprintf(yyout, pfDATA pfALIGN pfLABEL, mklbl(p->place = ++lbl));
                                            initarr(LEFT_CHILD(p)->value.i, 0); }
array: INTS(INT, ints)                  1 { p->place = RIGHT_CHILD(p)->place;
                                            initarr(LEFT_CHILD(p)->value.i, RIGHT_CHILD(p)->info); }

ints: INT                          isImut { fprintf(yyout, pfRODATA pfALIGN pfLABEL pfINTEGER, mklbl(p->place = ++lbl), p->value.i); }
ints: INT                         isnImut { fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, mklbl(p->place = ++lbl), p->value.i); }
ints: INTS(ints, INT)                   1 { fprintf(yyout, pfINTEGER, RIGHT_CHILD(p)->value.i);
                                            p->place = LEFT_CHILD(p)->place; }

main: START(mvarsb, instrs)             1 { lcvarcnt = 0; }

mvarsb: mvars                           1 { fprintf(yyout, pfENTER, lcvarcnt * 4); initlcarr(); }

mvars: NIL                              1 { fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_main", pfFUNC, "_main");
                                            imut = 1; }
mvars: ARGS(mvars, fvar)                1 { /**/ }

body: NIL                               1 { /**/ }
body: START(fvars, STMT(instrs, ret))   1 { /**/ }

ret: NIL                                1 { /**/ }
ret: RETURN(NIL)                        1 { /**/ }
ret: RETURN(expr)                       1 { /**/ }

block: STMT(instrs, NIL)                1 {  }
block: STMT(instrs, RETURN(NIL))        1 { /**/ }
block: STMT(instrs, RETURN(expr))       1 { /**/ }
block: STMT(instrs, REPEAT)             1 { fprintf(yyout, pfJMP, mkrlbl(p->place = ++lbl)); }
block: STMT(instrs, STOP)               1 { fprintf(yyout, pfJMP, mkslbl(p->place = ++lbl)); }

instrs: NIL                             1 { /**/ }
instrs: STMT(instrs, instr)             1 { /**/ }


%! /* For loop code selection and generation */

instr : FOR(fblock, UNTIL(uexpr, expr))  1 { fprintf(yyout, pfJZ, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place));
                                             printslb(); }

fblock : FBLOCK(fexpr, block)            1 { printrlb(); }

fexpr : instr                            1 { fprintf(yyout, pfJMP, mkflbl(++lbl));
                                             fprintf(yyout, pfLABEL, mklbl(p->place = ++lbl));
                                             rlb[++rlbl] = 0; slb[++slbl] = 0; }

uexpr : instr                            1 { fprintf(yyout, pfLABEL, mklbl(flb[flbl--])); }


%! /* If elif else conditions code selection and generation */

instr : FI(THEN(ifb, NIL), NIL)          1 { /**/ }
instr : FI(THEN(ifbe, elifsi), NIL)      1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place)); }
instr : FI(THEN(ifbe, elifsi), block)    1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place)); }

ifb : IF(ifexpr, block)                  1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
ifbe : IF(ifexpr, block)                 1 { fprintf(yyout, pfJMP pfLABEL, mkelbl(p->place = ++lbl), mklbl(LEFT_CHILD(p)->place)); }

ifexpr : expr                            1 { fprintf(yyout, pfJZ, mklbl(p->place = ++lbl)); }

elifsi : elifs                           1 { --elbl; }

elifs : NIL                              1 { /**/ }
elifs : ELIF(elifs, IF(ifexpr, block))   1 { fprintf(yyout, pfJMP pfLABEL, mklbl(elb[elbl]), mklbl(LEFT_CHILD(RIGHT_CHILD(p))->place)); }


%! /* Print code selection and generation */

instr: PRINT(expr)              isLeftInt { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_printi", 4, "_printi"); }
instr: PRINT(expr)              isLeftStr { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_prints", pfWORD, "_prints"); }


%! /* Allocation code selection and generation */

instr: ALLOC(expr, ID)                  1 { allocation(RIGHT_CHILD(p)->value.s, RIGHT_CHILD(p)->info); }

instr: expr                             1 { fprintf(yyout, pfTRASH, 4); }

ichars: chars                           1 { fprintf(yyout, pfCHAR pfTEXT pfALIGN pfADDR, 0, mklbl(p->place)); }  
ichars: CHARS(NIL, INT)                 1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
ichars: CHARS(NIL, CHAR)                1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }

lval: ID                            isGlb { fprintf(yyout, pfADDR, p->value.s); }
lval: ID                            isLoc { fprintf(yyout, pfLOCAL, getoffset(p->value.s) * 4); }
lval: INDEX(expr, ID)                   1 { indexation(RIGHT_CHILD(p)->value.s, RIGHT_CHILD(p)->info); }

exprval: expr                           1 { fprintf(yyout, pfDUP); }

expr: ichars                            1 { /**/ }
expr: lval                              1 { fprintf(yyout, pfLOAD); }
expr: READ                              1 { fprintf(yyout, pfCALL pfPUSH pfEXTRN, "_readi", "_readi"); }
expr: ADDR(lval)                        1 { /**/ }
expr: ADD(expr, expr)            isArgInt { fprintf(yyout, pfADD); }
expr: ADD(ID, expr)              isLftVec { vectoradd(LEFT_CHILD(p)->value.s); }
expr: ADD(expr, ID)              isRgtVec { vectoradd(RIGHT_CHILD(p)->value.s); }
expr: SUB(expr, expr)            isArgInt { fprintf(yyout, pfSUB); }
expr: SUB(ID, ID)                isArgVec { vectorsub(LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.s); }
expr: MULT(expr, expr)                  1 { fprintf(yyout, pfMUL); }
expr: DIV(expr, expr)                   1 { fprintf(yyout, pfDIV); }
expr: MOD(expr, expr)                   1 { fprintf(yyout, pfMOD); }
expr: EXP(expr, expr)                   1 { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_power", 8, "_power"); }
expr: EQ(expr, expr)             isArgInt { fprintf(yyout, pfEQ); }
expr: EQ(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfEQ pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: NE(expr, expr)             isArgInt { fprintf(yyout, pfNE); }
expr: NE(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfNE pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: GE(expr, expr)             isArgInt { fprintf(yyout, pfGE); }
expr: GE(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfGE pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: LE(expr, expr)             isArgInt { fprintf(yyout, pfLE); }
expr: LE(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfLE pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: LT(expr, expr)             isArgInt { fprintf(yyout, pfLT); }
expr: LT(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfLT pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: GT(expr, expr)             isArgInt { fprintf(yyout, pfGT); }
expr: GT(expr, expr)             isArgStr { fprintf(yyout, pfSWAP pfCALL pfTRASH pfPUSH pfIMM pfGT pfEXTRN, "_strcompr", 8, 0, "_strcompr"); }
expr: AND(and, expr)                    1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
expr: OR(or, expr)                      1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
expr: NOT(expr)                         1 { fprintf(yyout, pfIMM pfEQ, 0); }
expr: UMINUS(expr)                      1 { fprintf(yyout, pfNEG); }
expr: ASSOC(exprval, ID)       isRightGlb { fprintf(yyout, pfADDRA, RIGHT_CHILD(p)->value.s); }
expr: ASSOC(exprval, ID)       isRightLoc { fprintf(yyout, pfLOCA, getoffset(RIGHT_CHILD(p)->value.s) * 4); }
expr: ASSOC(exprval, lval)              1 { association(RIGHT_CHILD(RIGHT_CHILD(p))->info); }
expr: CALL(ID, exprs)            isResInt { /**/ }

and: expr                               1 { fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place = ++lbl), pfWORD); }
or: expr                                1 { fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place = ++lbl), pfWORD); }

exprs: NIL                              1 { /**/ }
exprs: PARAMS(expr, exprs)              1 { /**/ }

%%

extern char **yynames;
extern int trace, errors, debugNode;

void evaluate(Node *p) {
  if (errors)
    return;

  /* if (trace) */ printNode(p, stdout, yynames);

  if (!yyselect(p) && trace)
    printf("selection successful\n");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
  int op = OP_LABEL(p);
  YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";

  if (debugNode)
    fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);

  if (cost >= MAX_COST && bestcost >= MAX_COST) {
    fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
    printNode(p, stderr, yynames);
  }
}
#endif
