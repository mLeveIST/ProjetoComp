%{

/* -----------------------------------------
 * Compiladores 19/20 - Entrega Final
 * Author: Miguel Levezinho, No 90756
 * -----------------------------------------
 */

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;

static int strinit;

static int lbl;
static char *lb;

static char *mklbl(int n)
{
  static char buf[20];
  sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
  return strcpy(malloc(strlen(buf) + 1), buf);
}

static char *mkfunc(char *s)
{
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}

static int isInt(Node *n) { return tTYPE(n->info) == tINT ? 1 : 1000; }
static int isStr(Node *n) { return tTYPE(n->info) == tSTR ? 1 : 1000; }
static int isVec(Node *n) { return tTYPE(n->info) == tVEC ? 1 : 1000; }

static int isLeftInt(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tINT ? 1 : 1000; }
static int isLeftStr(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tSTR ? 1 : 1000; }
static int isLeftVec(Node *n) { return tTYPE(LEFT_CHILD(n)->info) == tVEC ? 1 : 1000; }

static void litstr(char *s)
{
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
}

%}

%term STMT=';' PRINT='!' ALLOC='#' INDEX='[' READ='?'
%term ADD='+' SUB='-' MULT='*' DIV='/' MOD='%' EXP='^'
%term EQ='=' LESS='<' GRT='>' AND='&' OR='|' NOT='~'
%term CALL='(' PARAMS=','

%include "y.tab.h"

%%

file: PROGRAM(decls, FUNCTION(END(ID, INT), FARGS(NIL, main)))      1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); }
file: MODULE(decls)                                                 1 { /**/ }

decls: gdecls                           1 { /**/ }

gdecls: NIL                             1 { /**/ }
gdecls: DECL(gdecls, decl)              1 { /**/ }

decl: NIL                                                 1 { /**/ }
decl: VAR(vardecl)                                        1 { /**/ }
decl: FUNCTION(END(ID, INT), FARGS(fvars, body))          1 { /**/ }

fvar: NUMBER(ID, NIL)                   1 { /**/ }
fvar: STRING(ID, NIL)                   1 { /**/ }
fvar: ARRAY(ID, INTS(INT, NIL))         1 { /**/ }

fvars: NIL                              1 { /**/ }
fvars: ARGS(fvars, fvar)                1 { /**/ }

vardecl: NUMBER(ID, NIL)                1 { fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, LEFT_CHILD(p)->value.s, 4); }
vardecl: NUMBER(ID, INT)                1 { fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.i); }
vardecl: STRING(ID, NIL)                1 { fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, LEFT_CHILD(p)->value.s, pfWORD); }
vardecl: STRING(ID, chars)              1 { fprintf(yyout, pfCHAR pfDATA pfALIGN pfLABEL pfID, 0, LEFT_CHILD(p)->value.s, lb); }
vardecl: ARRAY(ID, INTS(INT, NIL))      1 { /**/ }
vardecl: ARRAY(ID, INTS(INT, ints))     1 { /**/ }

chars: NIL                              1 { lb = mklbl(++lbl); fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb); }
chars: CHARS(chars, char)               1 { /**/ }

char: INT                               1 { fprintf(yyout, pfCHAR, (unsigned char) p->value.i); }
char: CHAR                              1 { fprintf(yyout, pfCHAR, (unsigned char) p->value.i); }
char: STR                               1 { litstr(p->value.s); }

ints: INT                               1 { /**/ }
ints: INTS(ints, INT)                   1 { /**/ }

main: START(fvars, minstrs)             1 { /**/ }

minstrs: NIL                            1 { fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "_main", pfFUNC, "_main", 0); }
minstrs: STMT(minstrs, instr)           1 { /**/ }

body: NIL                               1 { /**/ }
body: START(fvars, STMT(instrs, ret))   1 { /**/ }

ret: NIL                                1 { /**/ }
ret: RETURN(NIL)                        1 { /**/ }
ret: RETURN(expr)                       1 { /**/ }

block: STMT(instrs, NIL)                1 { /**/ }
block: STMT(instrs, RETURN(NIL))        1 { /**/ }
block: STMT(instrs, RETURN(expr))       1 { /**/ }
block: STMT(instrs, REPEAT)             1 { /**/ }
block: STMT(instrs, STOP)               1 { /**/ }

instrs: NIL                             1 { /**/ }
instrs: STMT(instrs, instr)             1 { /**/ }

instr: FI(THEN(IF(expr, block), elifs), else)             1 { /**/ }
instr: FOR(UNTIL(expr, expr), STEP(block, expr))          1 { /**/ }
instr: PRINT(expr)                                isLeftInt { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_printi", 4, "_printi"); }
instr: PRINT(sexpr)                               isLeftStr { fprintf(yyout, pfCALL pfTRASH pfPUSH pfEXTRN, "_prints", pfWORD, "_prints"); }
instr: PRINT(vexpr)                               isLeftVec { /**/ } 
instr: expr                                               1 { /**/ }
instr: ALLOC(expr, lval)                                  1 { /**/ }

elifs: NIL                              1 { /**/ }
elifs: ELIF(elifs, IF(expr, block))     1 { /**/ }

else: NIL                               1 { /**/ }
else: block                             1 { /**/ }

ichars: chars                           1 { /**/ }  
ichars: CHARS(NIL, INT)                 1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
ichars: CHARS(NIL, CHAR)                1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }

lval: ID                                1 { fprintf(yyout, pfADDR, p->value.s); }
lval: INDEX(expr, ID)                   1 { /**/ }

exprval: expr                           1 { fprintf(yyout, pfDUP); }

expr: ichars                            1 { /**/ }
expr: lval                              1 { fprintf(yyout, pfLOAD); }
expr: READ                              1 { /**/ }
expr: expr                              1 { /**/ }
expr: ADD(expr, expr)               isInt { /**/ }
expr: SUB(expr, expr)               isInt { /**/ }
expr: MULT(expr, expr)                  1 { /**/ }
expr: DIV(expr, expr)                   1 { /**/ }
expr: MOD(expr, expr)                   1 { /**/ }
expr: EXP(expr, expr)                   1 { /**/ }
expr: EQ(expr, expr)                isInt { /**/ }
expr: NE(expr, expr)                isInt { /**/ }
expr: GE(expr, expr)                isInt { /**/ }
expr: LE(expr, expr)                isInt { /**/ }
expr: LESS(expr, expr)              isInt { /**/ }
expr: GRT(expr, expr)               isInt { /**/ }
expr: AND(expr, expr)                   1 { /**/ }
expr: OR(expr, expr)                    1 { /**/ }
expr: NOT(expr, expr)                   1 { /**/ }
expr: UMINUS(expr)                      1 { /**/ }
expr: ASSOC(exprval, lval)          isInt { fprintf(yyout, pfSTORE); }
expr: CALL(ID, exprs)               isInt { /**/ }

sexpr: ichars                           1 { fprintf(yyout, pfCHAR pfTEXT pfADDR, 0, lb); }
sexpr: lval                             1 { /**/ }
sexpr: sexpr                            1 { /**/ }
sexpr: EQ(sexpr, sexpr)             isStr { /**/ }
sexpr: NE(sexpr, sexpr)             isStr { /**/ }
sexpr: GE(sexpr, sexpr)             isStr { /**/ }
sexpr: LE(sexpr, sexpr)             isStr { /**/ }
sexpr: LESS(sexpr, sexpr)           isStr { /**/ }
sexpr: GRT(sexpr, sexpr)            isStr { /**/ }
sexpr: ASSOC(sexpr, lval)           isStr { /**/ }
sexpr: CALL(ID, exprs)              isStr { /**/ }

vexpr: lval                             1 { /**/ }
vexpr: ADDR(lval)                       1 { /**/ }
vexpr: vexpr                            1 { /**/ }
vexpr: ADD(expr, vexpr)             isVec { /**/ }
vexpr: SUB(vexpr, vexpr)            isVec { /**/ }
vexpr: ASSOC(vexpr, lval)           isVec { /**/ }
vexpr: CALL(ID, exprs)              isVec { /**/ }

exprs: NIL                              1 { /**/ }
exprs: PARAMS(expr, exprs)              1 { /**/ }
exprs: PARAMS(sexpr, exprs)             1 { /**/ }
exprs: PARAMS(vexpr, exprs)             1 { /**/ }

%%

extern char **yynames;
extern int trace, errors, debugNode;

void evaluate(Node *p) {
  if (errors)
    return;

  /* if (trace) */ printNode(p, stdout, yynames);

  if (!yyselect(p) && trace)
    printf("selection successful\n");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
  int op = OP_LABEL(p);
  YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";

  if (debugNode)
    fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);

  if (cost >= MAX_COST && bestcost >= MAX_COST) {
    fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
    printNode(p, stderr, yynames);
  }
}
#endif
